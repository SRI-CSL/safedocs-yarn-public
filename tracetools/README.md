Please note that this README and the one at tracetools/README.md may
be out-of-date.

This is messy research code. Use at your own risk.

# Printing/parsing trace output

`tools/print_log.py` is a standalone python3 tool that simply parses
the binary output generated by the YARN memtrace's `run_trace.py`
tool/instrumentation and prints out the contents in a more
human-readable format.

## data collection

These tools assume that you have collected traces using
`memtrace/run_trace.py` (from the memtrace repo).  Although you can run
the dynamorio tools by themselves, `run_trace.py` wraps its test
results/logs in a form that the rest of these tools play nicely with.
See the memtrace repo for more information.

In short: every memtrace log processing tool determines which logs to
process via its -R command line argument, -R takes a single argument
which is the path to the session's results directory generated by
memtrace's `run_trace.py`, e.g., ` -R
/path/to/results/res_26977762b1254d13b008dbdc9693c8ed/`

Inside each `res_<session id>` are all logs/data collected during an
instrumented run of the parser AND a copy of the input the parser
processed.

Many tools also accept a `-l <lib name>` option, which can be
specified multiple times.  `-l` is used to tell the tool to include
the specified library in its results as well (not just events executed
directly by the parser executable). The library should be saved in the
sessoin's result's corresponding `bins_*./data` directory (i.e.,
`/results/res_26977762b1254d13b008dbdc9693c8ed` is merely a symbolic
link to
`/results/bins_889990001114dddddd7777777777777/res_26977762b1254d13b008dbdc9693c8ed/`,
copies of each library binary is located in
`/results/bins_889990001114dddddd7777777777777/data`) , and the value
specified with `-l` must match the name of a library in the
`bins_*/data` directory.


## memcalltrace To print the memcalltrace log in a human-readable
form, invoke print_log.py via:

> ./tools/print_log.py -R /path/to/session/results


There are multiple kinds of entries that a memcalltrace log file may
contain -- memory entries, call entries, instruction entries, register
value entries, file operation entries, mmap operations, file read
operations, malloc operations

### Memory entries (MemEntry)
When printed by print_log.py, memory log entries begin with "MI: "
The full human-readable line looks like
`MI: <pc>: <R(ead) or W(rite)> <# bytes> bytes to <destination address> [value]`
Note that value is only printed if it is a Read operation

### Call entries (CallEntry)
Call entries begin with "C: ".  If they are a direct or indirect call,
they look like:
`C: {*>, >, <} <target address> PC: <pc> TOS: <stack pointer>` where
- *> indicates a indirect call
- > indicates a direct call

If it is a function return, it looks like:
`C: < <target address> PC: <pc> RETVAL: <value>` where
 value is the the function's return value (contents of rax)



### Instruction entries (PCEntry)
These begin with "INS: " and are formatted as
`INS: <pc>`

where pc is the executed instruction's program counter at the
beginning of each invoked basic block.  Basic block tracking is not
enabled by default in the dynamorio tool.

### Malloc operations

Begin with "MALLOC" and are formatted as

`MALLOC: <MALLOC_TYPE> - <start addr>-<end addr>`

or

`MALLOC: <FREE_TYPE> - <addr>`

MALLOC_TYPE is one of: MALLOC (regular malloc() call), CALLOC (call to calloc()), REALLOC, or REALLOCARRAY

if the malloc type is REALLOC or REALLOCARRAY, the malloc entry will
be proceeded by a FREE_REALLOC or FREE_REALLOCARRAY entry with
information on the original location of the allocation in case it is
moved.

FREE_TYPE is one of:  FREE (if object directly freed with free()), REALLOC_FREE, or REALLOCARRAY_FREE


### File operation entry (FileOpEntry)

`F_OP: fd <file descriptor #> @ <program counter> - <operation kind>`

operation kind is one of: OPEN, CLOSE, READ, MMAP, MUNMAP

fd # for MUNMAP operations are all set to 0

### File read entry (FileReadEntry)

For now only reads of the input/parsed file are traced These entries
represent the system calls read() or pread64() made against the input
(parsed) file.  There will be one of these directly following a
FileOpEntry if the FileOpEntry's type is READ and its file descriptor is that of
the input being parsed.

`F_RD: fd <file descriptor #> @ offsets <file offset low>-<file offset high> to addr <location in memory>`

### Mmap entry (MmapEntry)

For now only mmap operations of the input/parsed file are traced.  A
file descriptor set to 0 indicates the region has been unmapped. There
will be one of these directly following a FileOpEntry if the
FileOpEntry's type is MUNMAP or it is MMAP and the file descriptor
matches the input (parsed) file.

`MMAP: file <file offset> to <low addr>-<high addr>`
or
`MMAP: unmap <low addr>-<high addr>`


## SigEntry
For signals recieved by the instructed process
`Sig: <signal #> at <pc>`

## Log{On,Off}Entry
These entries mark when memtrace logging was enabled or disabled,
along with the current program counter of the application

`LOGGING ENABLED @ <pc>`
or
`LOGGING DISABLED @ <pc>`

# Installing

These tools require binaryninja and its python bindings to be
installed. A headless license is fine.

# Tools beyond log parsing
There are several log analysys tools that are included in this codebase,
they all live under the tools/ directory.

All of these tools require use of the -R option, some allow it to be
specified more than once:
-R <path to session results directory>

## print_log.py
We already discussed this

## print_callstack.py
Prints out callstack from results log in a human readable format.
Use -d to tell it to demangle function names.
Use -e to tell it to print in an emacs org-mode/outline-friendly manner
Use --index to tell it to prepend each line of output with that line's call stack index (in reality this should be equivalent to the line number)
Use -o to tell it were to write the results instaed of stdout
Use -l <library name> to tell it to also print functions defined in the given shared library

## callstack_diff.py
Prints information on how the call stacks differ.
You must use the -R option twice to tell it what results to compare.
Use -o to tell it where to write results,
You can use -s to tell it which functions to skip
Use -f to instruct the tool to instead print a summary of functions called that are unique to each result log
Use -l <library name> to tell it to also print functions defined in the given shared library

## log_console.py
Sets up environment to process results log and opens an iPython
console so that you can explore log on your own
(This is intended for advanced users)

## count_calls.py

Count number of times one or more functions are called, specified as
argument (use this more than once in order to track calls to multiple
functions.

-f <function>

# Signatures and MoR

## Example: detecting object number of fetched indirect object in mupdf 1.18.0

In mupdf, `pdf_cache_object` is generally invoked whenever an
indrerect object needs to be fetched and parsed given the object's number.

Its signature is as follows (defined on line 2020 of pdf-xref.c):
```c
pdf_xref_entry * pdf_cache_object(fz_context *ctx, pdf_document *doc, int num)

```

`fz_context` and `pdf_document` give `pdf_cache_object` all the
information it needs to locate and parse the indirect object whose
number is supecified by the last parameter, `num`.

The parameters to `pdf_cache_object` are not directly exposed by
memtrace logging, but the logging will capture the value of `num`
if it is written to (or read from) memory.

Here is a statement early on in `pdf_cache_object` that reads `num`,
the `if` statement is line 2027 of pdf-xref.c

```c
	if (num <= 0 || num >= pdf_xref_len(ctx, doc))
		fz_throw(ctx, FZ_ERROR_GENERIC, "object out of range (%d 0 R); xref size %d", num, pdf_xref_len(ctx, doc));

```

We will first use gdb to inspect the built mutool binary (build with
debugging optimizations only and with debugging symbols) to see if the
value of `num` is read from memory when the `if` statement is
executed.

After loading mutool into gdb, we ask it for the virtual addresses of
the bytecode generated for the `if` statement (line 2028 of pdf-xref.c)

```
(gdb) info line pdf-xref.c:2027
Line 2027 of "source/pdf/pdf-xref.c" starts at address 0x192a72 <pdf_cache_object+46> and ends at 0x192a90 <pdf_cache_object+76>.
```

Next we use gdb to inspect the disassembled bytecode at this address

```
(gdb) x/10i 0x192a72
   0x192a72 <pdf_cache_object+46>:	cmpl   $0x0,-0x34(%rbp)
   0x192a76 <pdf_cache_object+50>:	jle    0x192a90 <pdf_cache_object+76>
   0x192a78 <pdf_cache_object+52>:	mov    -0x30(%rbp),%rdx
   0x192a7c <pdf_cache_object+56>:	mov    -0x28(%rbp),%rax
   0x192a80 <pdf_cache_object+60>:	mov    %rdx,%rsi
   0x192a83 <pdf_cache_object+63>:	mov    %rax,%rdi
   0x192a86 <pdf_cache_object+66>:	call   0x18d300 <pdf_xref_len>
   0x192a8b <pdf_cache_object+71>:	cmp    %eax,-0x34(%rbp)
   0x192a8e <pdf_cache_object+74>:	jl     0x192aca <pdf_cache_object+134>
   0x192a90 <pdf_cache_object+76>:	mov    -0x30(%rbp),%rdx
(gdb)

```

Given the source code, we know we should expect a comparison of `num`
to 0 followed by a comparizon of `num` to some calculated value.  We
can see that the disassembled code contains 2 `cmp` instructions, the
first one comparing the literal `$0x0` to the value at address
`-0x34(%rbp)`, the second one compares `%eax` to (presumably the same
address).  Thus we can be fairly confident that any memory read made
while servicing a `cmd` instruction within this block of instructions
will be reading the value of `num`.

If we want to write a signature that gets the value of this specific
memory read, we first must describe this memory read in our address
cache dsl/mupdf signature description json.

```json
	"pdf_cache_obj_num": {
		"path": "source/pdf/pdf-xref.c",
		"lineno": 2027,
		"kind": "MemEntry",
		"subtype": "read",
		"ins_type": "cmp"
	},
```

The address cache generator (`gen_bin_metadata.py`) ingests a file
containing this (and other) descriptions, along with other information
on the parser build, as well as the parser binary (with debugging
symbols) to lookup all of the describes instructions/addresses in the
binary and generates a json file (I refer to as an address cache) that
contains address name to virtual address mappings for the binary. When
YARN signatures are run against as set of test results, YARN's
signature/analysis framework loads the appropriate address cache
(based on which parser binary produces the test results) and allows
signatures or other plugins to ask it for the absolute address of any
address in the cache by name. E.g.,
`tracetools.signatures.versions.Version.get("mupdf").addrs_of("pdf_cache_obj_num")`


The property name of this json object is merely a unique name that the
signature can use to lookup the instruction's address while analyzing
a memtrace log.  `path` and `lineno` indicate the path and line number
(respectively) that contains the instruction of interest (debugging
symbols are used to narrow now the search).  "kind" helps the cache
generate narrow it's search to specific kinds of instructions --
"MemEntry" means that it should only search instructions that read and
write memory. (Other options include "PCEntry" which means that the
instruction should be at the beginning of a basic block, "CallEntry"
which means that the instruction is a call or return instruction,
etc.)  `"subtype": "read"` says that we are looking for instructions
that read memory ("write" is also a valid subtype for "MemEntry").
Finally `"ins_type": "cmp"` indicates that we are only interested in
memory reads done while servicing a comparision instruction.

Given the descriptions of `pdf_cache_obj_num` and the corresponding
bytecode, we will end up with a `pdf_cache_obj_num` entry that
contains two addresses (one for each `cmp`): [0x192a72, 0x192a8b].

We can then write a simple script that given some test results, (1)
looks up the absolute addresses of `pdf_cache_obj_num`, (2)
iterates through all log entries of type "MemEntry" until it finds one
whose program counter matches an absolute address of
`pdf_cache_obj_num`, and (3) prints out the value of the memory read.

# quicksect patch

memtrace-tools needs a patched version of quicksect that allows it to
work with 64-bit integers.  You can create a patched version via:
```
>  curl -L -q https://github.com/brentp/quicksect/archive/refs/tags/v0.2.2.tar.gz | tar -xz && mv quicksect-0.2.2 quicksect
> patch -p0 -l < quicksect.patch
```

You can then install this version via:
```
> cd quicksect && python setup.py install
```
# License
This code is released under the MIT License

The MIT License (MIT)

Copyright (c) 2022 Narf Industries LLC

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
